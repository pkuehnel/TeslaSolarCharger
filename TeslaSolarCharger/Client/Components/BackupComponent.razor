@page "/backupAndRestore"
@using System.Globalization
@using TeslaSolarCharger.Shared
@using TeslaSolarCharger.Shared.Dtos
@using TeslaSolarCharger.Shared.Localization.Contracts
@using TeslaSolarCharger.Shared.Localization.Registries
@using TeslaSolarCharger.Shared.Localization.Registries.Components
@using TeslaSolarCharger.Shared.Resources
@inject IJSRuntime JsRuntime
@inject ISnackbar Snackbar
@inject IHttpClientFactory HttpClientFactory
@inject ILogger<BackupComponent> Logger
@inject ITextLocalizationService TextLocalizer

@implements IDisposable

<h1>@T("Backup and Restore")</h1>
<div>@T("During the backup or restore process all TSC actions will be stopped and started again after the Backup")</div>

<h2>@T("Backup")</h2>
<div class="alert alert-warning" role="alert">
    @T("Note: The backup contains private information like password for your database, possibly access codes to your solar system, latest known location of your car(s),... Do not share the backup in public.")
</div>

@if (_processingBackup)
{
    <MudPaper Class="d-flex justify-end flex-grow-1 gap-4 pr-2 mb-2" Elevation="0">
        <MudAlert Severity="Severity.Info">
            @T("Backup creation might take a few minutes, please wait...")
        </MudAlert>
    </MudPaper>
}
<RightAlignedButtonComponent IsDisabled="@(_processingBackup || _processingRestore)"
                             OnButtonClicked="StartBackup"
                             IsLoading="_processingBackup"
                             ButtonText='@T("Start Backup")'></RightAlignedButtonComponent>
<hr />
<h2>@T("Restore")</h2>
<div class="alert alert-warning" role="alert">
    @T("After the restore process you need to restart the TSC container.")
</div>
<div class="mb-2">
    <MudFileUpload T="IBrowserFile" FilesChanged="SelectFile" Accept=".zip" MaximumFileCount="1">
        <ActivatorContent>
            <MudButton HtmlTag="label"
                       Disabled="@(_processingBackup || _processingRestore)"
                       Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Material.Filled.AttachFile">
                @T("Select Backup File")
            </MudButton>
        </ActivatorContent>
    </MudFileUpload>
</div>
@if (_file != default)
{
    <div class="mb-2">
        @_file.Name <code>@((_file.Size * 0.000001).ToString("0.00", CultureInfo.CurrentCulture)) MB</code>
    </div>
}

@if (UploadProgress != default && UploadProgress.Value != null && UploadProgress.MaxValue != null)
{
    <div class="mb-3">
        <MudProgressLinear Value="UploadProgress.Value.Value"
                           Max="UploadProgress.MaxValue.Value"
                           Size="Size.Large"
                           Striped="true"
                           Color="Color.Primary" />
    </div>
}

<RightAlignedButtonComponent IsDisabled="@(_processingBackup || _processingRestore || _file == default)"
                             DisabledToolTipText=""
                             OnButtonClicked="StartRestore"
                             IsLoading="_processingRestore"
                             ButtonText='@T("Start restore")'></RightAlignedButtonComponent>

<MudExpansionPanels>
    <MudExpansionPanel Text="@T("Automatically created backups before each update")" ExpandedChanged="RefreshBackups">
        <MudDataGrid Items="_backupFiles">
            <Columns>
                <PropertyColumn Property="x => x.FileName"></PropertyColumn>
                <PropertyColumn Property="x => x.CreationDate"></PropertyColumn>
                <TemplateColumn CellClass="d-flex justify-end">
                    <CellTemplate>
                        <MudButton Size="@Size.Small"
                                   Variant="@Variant.Filled"
                                   Color="@Color.Primary"
                                   StartIcon="@Icons.Material.Filled.Download"
                                   OnClick="@(_ => DownloadFile(context.Item.FileName))">@T("Download")</MudButton>
                    </CellTemplate>
                </TemplateColumn>
            </Columns>
        </MudDataGrid>
    </MudExpansionPanel>
</MudExpansionPanels>

@code {
    private bool _processingBackup;
    private bool _processingRestore;
    private const long MaxFileSize = 4294967296; // 4GB
    private List<DtoBackupFileInformation> _backupFiles = new List<DtoBackupFileInformation>();
    private IBrowserFile? _file;
    private DotNetObjectReference<BackupComponent>? _objRef;
    private DtoProgress? UploadProgress { get; set; }

    protected override void OnInitialized()
    {
        _objRef = DotNetObjectReference.Create(this);
    }

    private async Task StartBackup()
    {
        _processingBackup = true;
        await InvokeAsync(StateHasChanged);

        var fileName = "TSCBackup.zip";
        var cookieName = $"download_{Guid.NewGuid():N}";
        var url = $"api/BaseConfiguration/DownloadBackup?cookieName={cookieName}";

        try
        {
            await JsRuntime.InvokeVoidAsync("triggerFileDownloadWithCallback",
                fileName, url, cookieName, _objRef, nameof(OnDownloadStarted));
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error while starting backup download");
            Snackbar.Add(ex.Message, Severity.Error);
            _processingBackup = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task OnDownloadStarted()
    {
        _processingBackup = false;
        await InvokeAsync(StateHasChanged);
    }

    private void SelectFile(IBrowserFile? file)
    {
        if (file == default)
        {
            return;
        }
        if (file.Size > MaxFileSize)
        {
            Snackbar.Add(string.Format(CultureInfo.CurrentCulture, T("{0} is greater than {1} and won't be uploaded."), file.Name, MaxFileSize / 1024 / 1024),
                Severity.Error);
        }
        _file = file;
    }

    private async Task StartRestore()
    {
        _processingRestore = true;
        if (_file == default)
        {
            Snackbar.Add(T("No file selected"), Severity.Error);
            _processingRestore = false;
            return;
        }

        UploadProgress = new DtoProgress { Value = 0, MaxValue = _file.Size };
        await InvokeAsync(StateHasChanged);

        try
        {
            using var httpClient = HttpClientFactory.CreateClient(StaticConstants.LongTimeOutHttpClientName);
            var chunkSize = 10 * 1024 * 1024;
            var totalChunks = (int)Math.Ceiling((double)_file.Size / chunkSize);
            var stream = _file.OpenReadStream(MaxFileSize);
            await using var stream1 = stream.ConfigureAwait(true);
            var buffer = new byte[chunkSize];
            var chunkNumber = 0;
            int bytesRead;
            while ((bytesRead = await stream.ReadAsync(buffer, 0, chunkSize)) > 0)
            {
                chunkNumber++;
                using var content = new MultipartFormDataContent();
                var byteContent = new ByteArrayContent(buffer, 0, bytesRead);
                content.Add(byteContent, "file", _file.Name);
                content.Add(new StringContent(_file.Name), "fileName");
                content.Add(new StringContent(chunkNumber.ToString()), "chunkNumber");
                content.Add(new StringContent(totalChunks.ToString()), "totalChunks");

                var response = await httpClient.PostAsync("api/BaseConfiguration/RestoreBackup", content);
                if (!response.IsSuccessStatusCode)
                {
                    Snackbar.Add(string.Format(CultureInfo.CurrentCulture, T("Error while restoring backup: {0}"), response.ReasonPhrase), Severity.Error);
                    _processingRestore = false;
                    UploadProgress = null;
                    return;
                }

                UploadProgress.Value += bytesRead;
                await InvokeAsync(StateHasChanged);
            }

            Snackbar.Add(T("Backup file saved. Container restart required to complete restore. Please restart the TSC container now."), Severity.Success);
            _file = null;
            UploadProgress = null;
        }
        catch (Exception e)
        {
            Snackbar.Add(string.Format(CultureInfo.CurrentCulture, T("Fatal Error while restoring backup: {0}"), e.Message), Severity.Error);
            Logger.LogError(e, "Error while restoring backup");
            UploadProgress = null;
            _processingRestore = false;
            return;
        }

        _processingRestore = false;
    }

    private async Task RefreshBackups(bool arg)
    {
        if (!arg)
        {
            return;
        }
        try
        {
            using var httpClient = HttpClientFactory.CreateClient(StaticConstants.NormalTimeOutHttpClientName);
            var backupFiles = await httpClient.GetFromJsonAsync<List<DtoBackupFileInformation>>("api/BaseConfiguration/GetAutoBackupFileInformations");
            if (backupFiles != null)
            {
                _backupFiles = backupFiles;
            }
            else
            {
                Snackbar.Add(T("No backups found"), Severity.Info);
            }
        }
        catch (Exception e)
        {
            Snackbar.Add(string.Format(CultureInfo.CurrentCulture, T("Error while refreshing backups: {0}"), e.Message), Severity.Error);
        }
    }

    private async Task DownloadFile(string itemFileName)
    {
        var url = $"api/BaseConfiguration/DownloadAutoBackup?fileName={Uri.EscapeDataString(itemFileName)}";
        await JsRuntime.InvokeVoidAsync("triggerFileDownload", itemFileName, url);
    }

    public void Dispose()
    {
        _objRef?.Dispose();
    }

    private string T(string key) =>
        TextLocalizer.Get<BackupComponentLocalizationRegistry>(key, typeof(SharedComponentLocalizationRegistry))
        ?? key;
}
