@using System.Globalization
@using TeslaSolarCharger.Client.Helper.Contracts
@using TeslaSolarCharger.Client.Services.Contracts
@using System.ComponentModel
@using TeslaSolarCharger.Shared.Attributes
@using TeslaSolarCharger.Shared.Dtos.Home
@using TeslaSolarCharger.Shared.Enums
@using TeslaSolarCharger.Shared.Localization
@using TeslaSolarCharger.Shared.SignalRClients
@using TeslaSolarCharger.Shared.Localization.Contracts
@using TeslaSolarCharger.Shared.Localization.Registries
@using TeslaSolarCharger.Shared.Localization.Registries.Components.StartPage

@inject IHomeService HomeService
@inject ISnackbar Snackbar
@inject ISignalRStateService SignalRStateService
@inject ILogger<CarDetailsComponent> Logger
@inject IJavaScriptWrapper JavaScriptWrapper
@inject ITextLocalizationService TextLocalizer

@if (CarSettings == default || CarState == default)
{
    <PlaceholderComponent Count="6"></PlaceholderComponent>
}
else
{
    <div>
        <CustomIcon IconName="@Icons.Material.Outlined.DirectionsCar" Class="me-1" />
        <span class="me-1">@CarSettings.Name</span>
        @if (CarState.IsOnline != default)
        {
            <CustomIcon IconName="@Icons.Material.Filled.Wifi" IsCrossedOut="@(CarState.IsOnline == false)" TooltipText='@T(TranslationKeys.CarDetailsConnectedToServer)'></CustomIcon>
        }
        @if (CarSettings.CarType != CarType.Manual)
        {
            <CustomIcon IconName="@Icons.Material.Outlined.Home" IsCrossedOut="@(!CarState.IsHome)" TooltipText='@T(TranslationKeys.CarDetailsAtHome)'></CustomIcon>
        }
        <CustomIcon IconName="@Icons.Material.Outlined.Power" IsCrossedOut="@(!CarState.IsPluggedIn)" TooltipText='@T(TranslationKeys.CarDetailsPluggedIn)'></CustomIcon>
        <CustomIcon IconName="@Icons.Material.Outlined.Bolt" IsCrossedOut="@(!CarState.IsCharging)" TooltipText='@T(TranslationKeys.CarDetailsCharging)'></CustomIcon>
    </div>
    @if (CarSettings.CarType == CarType.Tesla)
    {
        <FleetApiTestComponent CarId="CarId" />
    }
    @if (CarState.FleetTelemetryDataState == FleetTelemetryDataState.NotEnoughTimeSinceReconnect)
    {
        <MudAlert Severity="Severity.Warning" Class="mb-3">
            @T(TranslationKeys.CarDetailsFleetTelemetryWarningTime)
        </MudAlert>
    }
    else if (CarState.FleetTelemetryDataState == FleetTelemetryDataState.CarNotConnectedAfterEnoughTimeAfterReconnect)
    {
        <MudAlert Severity="Severity.Warning" Class="mb-3">
            @T(TranslationKeys.CarDetailsFleetTelemetryWarningSleep)
        </MudAlert>
    }

    @if (CarState.Soc != default)
    {
        <ProgressWithLabelComponent Color="@(CarState.Soc.Value < 7 ? Color.Error : CarState.Soc.Value <= 20 ? Color.Warning : Color.Primary)"
                                    Striped="CarState.IsCharging"
                                    Size="Size.Large"
                                    Value="(double)CarState.Soc"
                                    Buffer="@(CarState.CarSideSocLimit != default)"
                                    BufferValue="@(CarState.CarSideSocLimit == default ? 0 : (double)CarState.CarSideSocLimit.Value)"
                                    ValueLabelPrefix='@T(TranslationKeys.CarDetailsSocLabel)'
                                    ValueLabelSuffix="%"
                                    BufferLabelPrefix='@T(TranslationKeys.CarDetailsCarLimitLabel)'
                                    BufferLabelSuffix="%">
        </ProgressWithLabelComponent>
    }
    @if (CarSettings.CarType == CarType.Manual)
    {
        if (CarState.Soc == default)
        {
            <MudAlert Severity="Severity.Warning" Class="my-3">
                @T(TranslationKeys.CarDetailsManualSocWarning)
            </MudAlert>
        }
        <GenericInput T="int?"
                      For="() => ManualSocToSet"
                      LabelName='@T(TranslationKeys.CarDetailsStateOfChargeLabel)'
                      OnValueChanged="SetManualSoc" />
    }
    <div>
        <div class="d-flex align-items-center">
            <div class="flex-grow-1">
                <GenericInput T="ChargeModeV2"
                              For="() => CarSettings.ChargeMode"
                              LabelName='@T(TranslationKeys.CarDetailsChargeModeLabel)'
                              OnValueChanged="ChargeModeUpdated" />
            </div>
            <div class="me-2 flex-grow-0">
                <MudIconButton Icon="@Icons.Material.Outlined.Info"
                               Color="Color.Primary"
                               OnClick="@(_ => JavaScriptWrapper.OpenUrlInNewTab("https://github.com/pkuehnel/TeslaSolarCharger?tab=readme-ov-file#charge-modes"))" />
            </div>
        </div>

        @if (CarSettings.ChargeMode == ChargeModeV2.Auto)
        {
            <div class="row">
                <div class="col-12 col-md-6">
                    <GenericInput T="int?"
                                  For="() => CarSettings.MinSoc"
                                  OnValueChanged="OnMinSocChanged"
                                  ImmediateValueUpdate="true" />

                </div>
                <div class="col-12 col-md-6">
                    <GenericInput T="int?"
                                  For="() => CarSettings.MaxSoc"
                                  OnValueChanged="OnMaxSocChanged"
                                  ImmediateValueUpdate="true" />
                </div>
            </div>
        }
        else if (CarSettings.ChargeMode == ChargeModeV2.Manual)
        {
            @if (CarSettings.CarType == CarType.Tesla)
            {
                <MudAlert Severity="Severity.Info" Class="mb-3">
                    @T(TranslationKeys.CarDetailsManualModeTeslaHint)
                </MudAlert>
                <GenericInput For="() => CurrentToSet"
                              LabelName='@T(TranslationKeys.CarDetailsCurrentToSetLabel)'></GenericInput>
                <RightAlignedButtonComponent ButtonText='@T(TranslationKeys.CarDetailsSetCurrentButton)'
                                             IsLoading="@_isCommandLoading"
                                             OnButtonClicked="@(SetCurrent)"></RightAlignedButtonComponent>
            }
            else if (ChargingConnectorId == default)
            {
                <MudAlert Severity="Severity.Info" Class="mb-3">
                    @T(TranslationKeys.CarDetailsManualModeNoOcppHint)
                </MudAlert>
            }
            else
            {
                <ManualOcppChargingComponent ChargingConnectorId="ChargingConnectorId" />
            }
        }
    </div>

    @if (CarId != default)
    {
        <div class="mb-7">
            <ChargingTargetConfigurationComponent CarId="CarId.Value"></ChargingTargetConfigurationComponent>
        </div>
    }

    <ChargeSummaryComponent CarId="CarId"></ChargeSummaryComponent>
}

@code {
    [Parameter]
    public int? CarId { get; set; }

    [Parameter]
    public int? ChargingConnectorId { get; set; }

    private DtoCarOverviewSettings? CarSettings { get; set; }

    private DtoCarOverviewState? CarState { get; set; }

    // one CTS per “in-flight” debounce
    private CancellationTokenSource _minSocDebounceCts = new();

    private int? _lastKnownMinValue;
    private int? _lastKnownMaxValue;
    private ChargeModeV2? _lastKnownChargeMode;
    private const int LimitChangeDelayMilliseconds = 1000;

    [Postfix("A")]
    private int? CurrentToSet { get; set; }
    [Postfix("%")]
    private int? ManualSocToSet { get; set; }
    private bool _isCommandLoading;

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        await RefreshData();

        if (CarId == default)
        {
            return;
        }
        await SignalRStateService.Subscribe<DtoCarOverviewState>(
            DataTypeConstants.CarOverviewState,
            async void (state) =>
            {
                try
                {
                    CarState = state;
                    await InvokeAsync(StateHasChanged);
                }
                catch (Exception e)
                {
                    Logger.LogError(e, "Failed to update car state for CarId: {CarId}", CarId);
                }
            },
            CarId.Value.ToString());

        CarState = await SignalRStateService.GetStateAsync<DtoCarOverviewState>(
            DataTypeConstants.CarOverviewState,
            CarId.Value.ToString());
    }

    private async Task RefreshData()
    {
        if (CarId == default)
        {
            CarSettings = default;
            return;
        }
        CarSettings = await HomeService.GetCarOverview(CarId.Value);
        if (CarSettings != default)
        {
            _lastKnownMinValue = CarSettings.MinSoc;
            _lastKnownMaxValue = CarSettings.MaxSoc;
            _lastKnownChargeMode = CarSettings.ChargeMode;
        }

    }

    private async Task OnMinSocChanged(int? newSoc)
    {
        if (CarSettings == default || CarId == default)
            return;

        // update UI immediately
        CarSettings.MinSoc = newSoc;

        // cancel any pending update
        await _minSocDebounceCts.CancelAsync();
        _minSocDebounceCts = new CancellationTokenSource();

        try
        {
            // wait 300ms for “settle”
            await Task.Delay(LimitChangeDelayMilliseconds, _minSocDebounceCts.Token);

            // now do the API call
            var updateResult = await HomeService.UpdateCarMinSoc(CarId.Value, newSoc ?? 0);
            if (updateResult.HasError)
            {
                Snackbar.Add(
                    Format(TranslationKeys.CarDetailsFailedToUpdateMinSoc, updateResult.ErrorMessage),
                    Severity.Error);
                if (_lastKnownMinValue != default)
                {
                    CarSettings.MinSoc = _lastKnownMinValue.Value;
                    await InvokeAsync(StateHasChanged);
                }
            }
            else
            {
                _lastKnownMinValue = newSoc;
                Snackbar.Add(T(TranslationKeys.CarDetailsMinSocUpdated), Severity.Success);
            }
        }
        catch (TaskCanceledException)
        {
            // user is still dragging—ignore
        }
    }


    private async Task OnMaxSocChanged(int? newSoc)
    {
        if (CarSettings == default || CarId == default)
            return;

        // cancel any pending update
        await _minSocDebounceCts.CancelAsync();
        _minSocDebounceCts = new CancellationTokenSource();

        try
        {
            // wait 300ms for “settle”
            await Task.Delay(LimitChangeDelayMilliseconds, _minSocDebounceCts.Token);
            // now do the API call
            var updateResult = await HomeService.UpdateCarMaxSoc(CarId.Value, newSoc ?? 100);
            if (updateResult.HasError)
            {
                Snackbar.Add(
                    Format(TranslationKeys.CarDetailsFailedToUpdateMaxSoc, updateResult.ErrorMessage),
                    Severity.Error);
                if (_lastKnownMaxValue != default)
                {
                    CarSettings.MaxSoc = _lastKnownMaxValue.Value;
                    await InvokeAsync(StateHasChanged);
                }
            }
            else
            {
                _lastKnownMaxValue = newSoc;
                Snackbar.Add(T(TranslationKeys.CarDetailsMaxSocUpdated), Severity.Success);
            }
        }
        catch (TaskCanceledException)
        {
            // user is still dragging—ignore
        }
    }

    private async Task ChargeModeUpdated(ChargeModeV2 arg)
    {
        if (CarSettings == default || CarId == default)
            return;
        var result = await HomeService.UpdateCarChargeMode(CarId.Value, arg);
        if (result.HasError)
        {
            Snackbar.Add(Format(TranslationKeys.CarDetailsFailedToUpdateChargeMode, result.ErrorMessage), Severity.Error);
            if (_lastKnownChargeMode != default)
            {
                CarSettings.ChargeMode = _lastKnownChargeMode.Value;
                await InvokeAsync(StateHasChanged);
            }
        }
        else
        {
            _lastKnownChargeMode = arg;
            Snackbar.Add(T(TranslationKeys.CarDetailsChargeModeUpdated), Severity.Success);
        }
    }

    private async Task SetCurrent()
    {
        if (CarId == default)
        {
            return;
        }
        if (CurrentToSet == default || CurrentToSet < 0)
        {
            Snackbar.Add(T(TranslationKeys.CarDetailsValidCurrentRequired), Severity.Error);
            return;
        }
        _isCommandLoading = true;
        var result = await HomeService.SetCarChargingCurrent(CarId.Value, CurrentToSet.Value);
        _isCommandLoading = false;
        if (result.HasError)
        {
            Snackbar.Add(Format(TranslationKeys.CarDetailsErrorFormat, result.ErrorMessage), Severity.Error);
        }
        else
        {
            Snackbar.Add(T(TranslationKeys.CarDetailsCommandSent), Severity.Success);
        }
    }

    private async Task SetManualSoc()
    {
        if (CarId == default)
        {
            return;
        }

        if (ManualSocToSet == default)
        {
            Snackbar.Add(T(TranslationKeys.CarDetailsValidSocRequired), Severity.Error);
            return;
        }

        var manualSoc = ManualSocToSet.Value;
        if (manualSoc < 0 || manualSoc > 100)
        {
            Snackbar.Add(T(TranslationKeys.CarDetailsSocRangeError), Severity.Error);
            return;
        }

        var result = await HomeService.UpdateManualCarSoc(CarId.Value, manualSoc);
        if (result.HasError)
        {
            Snackbar.Add(Format(TranslationKeys.CarDetailsErrorFormat, result.ErrorMessage), Severity.Error);
            return;
        }

        Snackbar.Add(T(TranslationKeys.CarDetailsSocUpdated), Severity.Success);
        ManualSocToSet = null;
        StateHasChanged();
    }

    private string T(string key) =>
        TextLocalizer.Get<CarDetailsComponentLocalizationRegistry>(key, typeof(SharedComponentLocalizationRegistry))
        ?? key;

    private string Format(string key, params object?[] arguments) =>
        string.Format(CultureInfo.CurrentCulture, T(key), arguments);
}
