@using TeslaSolarCharger.Client.Services.Contracts
@using TeslaSolarCharger.Shared.Contracts
@using TeslaSolarCharger.Shared.Dtos.Home
@using TeslaSolarCharger.Shared.Localization.Contracts
@using TeslaSolarCharger.Shared.SignalRClients
@inject IHomeService HomeService
@inject IDateTimeProvider DateTimeProvider
@inject ILogger<NotChargingAtExpectedPowerReasonsComponent> Logger
@inject ISignalRStateService SignalRStateService
@inject IAppLocalizationService LocalizationService

@implements IDisposable

@if (_elements == default)
{
    <PlaceholderComponent Count="2" />
}
else
{
    <MudExpansionPanels>
        <MudExpansionPanel @bind-Expanded="_isExpanded" HideIcon="true">
            <TitleContent>
                <div class="d-flex">
                    @{
                        var nextEndingReason = GetNextEndingReason();
                        if (nextEndingReason != null && !_isExpanded)
                        {
                            var remainingTime = GetRemainingTime(nextEndingReason.ReasonEndTime!.Value);
                            if (remainingTime.HasValue)
                            {
                                <div>
                                    @($"{GetReasonText(nextEndingReason)}:")
                                    <span><MudChip T="string"
                                                   Color="Color.Primary"
                                                   Size="Size.Small"
                                                   Icon="@Icons.Material.Filled.Timer">
                                        @(FormatTimeSpan(remainingTime.Value))
                                    </MudChip></span>
                                </div>

                            }
                        }
                        else
                        {
                            <div>@($"{_elements.Count} reason(s) why loadpoint charges with different power than you might expect")</div>
                        }
                    }
                    @if (_elements.Count > 0)
                    {
                        <MudBadge Content="@(_elements.Count)" Color="Color.Primary" Overlap="true" Class="d-flex ml-auto">
                            <MudIcon Icon="@(_isExpanded ? Icons.Material.Filled.KeyboardArrowUp : Icons.Material.Filled.KeyboardArrowDown)" Color="Color.Default" />
                        </MudBadge>
                    }
                </div>
            </TitleContent>
            <ChildContent>
                <ul>
                    @foreach (var element in _elements)
                    {
                        <li>
                            @if (element.ReasonEndTime == default)
                            {
                                @GetReasonText(element)
                            }
                            else
                            {
                                var remainingTime = GetRemainingTime(element.ReasonEndTime.Value);
                                @if (remainingTime.HasValue)
                                {
                                    @($"{GetReasonText(element)} (")
                                    <span>
                                        <MudChip T="string"
                                                 Color="Color.Primary"
                                                 Size="Size.Small"
                                                 Icon="@Icons.Material.Filled.Timer">
                                            @(FormatTimeSpan(remainingTime.Value))
                                        </MudChip>
                                    </span>
                                    <span>remaining)</span>
                                }
                                else
                                {
                                    @(GetReasonText(element))
                                }
                            }
                        </li>
                    }
                </ul>
            </ChildContent>
        </MudExpansionPanel>
    </MudExpansionPanels>
}

@code {
    [Parameter]
    public int? CarId { get; set; }

    [Parameter]
    public int? ChargingConnectorId { get; set; }

    private List<DtoNotChargingWithExpectedPowerReason>? _elements;
    private Timer? _countdownTimer;

    private bool _isExpanded = false;

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        await SignalRStateService.InitializeAsync();
        await SignalRStateService.SubscribeToTrigger(
            DataTypeConstants.NotChargingAsExpectedChangeTrigger,
            async void () =>
            {
                try
                {
                    await RefreshNotChargingWithExpectedPowerReasons();
                    await InvokeAsync(StateHasChanged).ConfigureAwait(false);
                }
                catch (Exception e)
                {
                    Logger.LogError(e, "{method}() failed", nameof(RefreshNotChargingWithExpectedPowerReasons));
                }
            });

        await RefreshNotChargingWithExpectedPowerReasons();
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Start the countdown timer - updates every second
        _countdownTimer = new(async void (_) =>
        {
            try
            {
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception e)
            {
                Logger.LogError(e, "Failed to update NotChargingAtExpectedPowerReasonsComponent state");
            }
        }, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
    }

    private async Task RefreshNotChargingWithExpectedPowerReasons()
    {
        if (CarId != default || ChargingConnectorId != default)
        {
            _elements = await HomeService.GetNotChargingWithExpectedPowerReasons(CarId, ChargingConnectorId);
        }
        else
        {
            _elements = null;
        }
    }

    private TimeSpan? GetRemainingTime(DateTimeOffset endTimeUtc)
    {
        var remaining = endTimeUtc - DateTimeProvider.DateTimeOffSetUtcNow();
        return remaining.TotalSeconds > 0 ? remaining : null;
    }

    private DtoNotChargingWithExpectedPowerReason? GetNextEndingReason()
    {
        if (_elements == null || _elements.Count == 0)
            return null;

        var currentTime = DateTimeProvider.DateTimeOffSetUtcNow();

        // Find the reason with the soonest end time that's still in the future
        return _elements
            .Where(e => e.ReasonEndTime.HasValue && e.ReasonEndTime.Value > currentTime)
            .OrderBy(e => e.ReasonEndTime!.Value)
            .FirstOrDefault();
    }

    private string FormatTimeSpan(TimeSpan timeSpan)
    {
        return timeSpan.ToString(@"mm\:ss");
    }

    private string GetReasonText(DtoNotChargingWithExpectedPowerReason reason)
    {
        if (reason == null)
        {
            return string.Empty;
        }

        return LocalizationService.GetString(reason.LocalizationKey ?? string.Empty, reason.Reason ?? reason.DefaultReason);
    }

    public void Dispose()
    {
        _countdownTimer?.Dispose();
    }
}
