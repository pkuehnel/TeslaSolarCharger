@using TeslaSolarCharger.Client.Services.Contracts
@using TeslaSolarCharger.Shared.Contracts
@using TeslaSolarCharger.Shared.Dtos.Home
@using TeslaSolarCharger.Shared.Localization
@using TeslaSolarCharger.Shared.SignalRClients
@inject IHomeService HomeService
@inject IDateTimeProvider DateTimeProvider
@inject ILogger<NotChargingAtExpectedPowerReasonsComponent> Logger
@inject ISignalRStateService SignalRStateService
@inject IAppStringLocalizer AppStringLocalizer

@implements IDisposable

@if (_elements == default)
{
    <PlaceholderComponent Count="2" />
}
else
{
    <MudExpansionPanels>
        <MudExpansionPanel @bind-Expanded="_isExpanded" HideIcon="true">
            <TitleContent>
                <div class="d-flex">
                    @{
                        var nextEndingReason = GetNextEndingReason();
                        if (nextEndingReason != null && !_isExpanded)
                        {
                            var remainingTime = GetRemainingTime(nextEndingReason.ReasonEndTime!.Value);
                            if (remainingTime.HasValue)
                            {
                                <div>
                                    @(AppStringLocalizer[LocalizationKeys.Components.NotChargingReasons.NextEndingKey, GetLocalizedReason(nextEndingReason)])
                                    <span><MudChip T="string"
                                                   Color="Color.Primary"
                                                   Size="Size.Small"
                                                   Icon="@Icons.Material.Filled.Timer">
                                        @(FormatTimeSpan(remainingTime.Value))
                                    </MudChip></span>
                                </div>
                                
                            }
                        }
                        else
                        {
                            <div>@(AppStringLocalizer[LocalizationKeys.Components.NotChargingReasons.HeadingKey, _elements.Count])</div>
                        }
                    }
                    @if (_elements.Count > 0)
                    {
                        <MudBadge Content="@(_elements.Count)" Color="Color.Primary" Overlap="true" Class="d-flex ml-auto">
                            <MudIcon Icon="@(_isExpanded ? Icons.Material.Filled.KeyboardArrowUp : Icons.Material.Filled.KeyboardArrowDown)" Color="Color.Default" />
                        </MudBadge>
                    }
                </div>
            </TitleContent>
            <ChildContent>
                <ul>
                    @foreach (var element in _elements)
                    {
                        <li>
                            @if (element.ReasonEndTime == default)
                            {
                                @GetLocalizedReason(element)
                            }
                            else
                            {
                                var remainingTime = GetRemainingTime(element.ReasonEndTime.Value);
                                @if (remainingTime.HasValue)
                                {
                                    <span>@GetLocalizedReason(element) (</span>
                                    <span>
                                        <MudChip T="string"
                                                 Color="Color.Primary"
                                                 Size="Size.Small"
                                                 Icon="@Icons.Material.Filled.Timer">
                                            @(FormatTimeSpan(remainingTime.Value))
                                        </MudChip>
                                    </span>
                                    <span>@AppStringLocalizer[LocalizationKeys.Components.NotChargingReasons.RemainingKey])</span>
                                }
                                else
                                {
                                    @GetLocalizedReason(element)
                                }
                            }
                        </li>
                    }
                </ul>
            </ChildContent>
        </MudExpansionPanel>
    </MudExpansionPanels>
}

@code {
    [Parameter]
    public int? CarId { get; set; }

    [Parameter]
    public int? ChargingConnectorId { get; set; }

    private List<DtoNotChargingWithExpectedPowerReason>? _elements;
    private Timer? _countdownTimer;

    private bool _isExpanded = false;

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        

        await SignalRStateService.InitializeAsync();
        await SignalRStateService.SubscribeToTrigger(
            DataTypeConstants.NotChargingAsExpectedChangeTrigger,
            async void () =>
            {
                try
                {
                    await RefreshNotChargingWithExpectedPowerReasons();
                    await InvokeAsync(StateHasChanged).ConfigureAwait(false);
                }
                catch (Exception e)
                {
                    Logger.LogError(e, "{method}() failed", nameof(RefreshNotChargingWithExpectedPowerReasons));
                }
            });

        await RefreshNotChargingWithExpectedPowerReasons();
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Start the countdown timer - updates every second
        _countdownTimer = new(async void (_) =>
        {
            try
            {
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception e)
            {
                Logger.LogError(e, "Failed to update NotChargingAtExpectedPowerReasonsComponent state");
            }
        }, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
    }

    private async Task RefreshNotChargingWithExpectedPowerReasons()
    {
        if (CarId != default || ChargingConnectorId != default)
        {
            _elements = await HomeService.GetNotChargingWithExpectedPowerReasons(CarId, ChargingConnectorId);
        }
        else
        {
            _elements = null;
        }
    }

    private TimeSpan? GetRemainingTime(DateTimeOffset endTimeUtc)
    {
        var remaining = endTimeUtc - DateTimeProvider.DateTimeOffSetUtcNow();
        return remaining.TotalSeconds > 0 ? remaining : null;
    }

    private DtoNotChargingWithExpectedPowerReason? GetNextEndingReason()
    {
        if (_elements == null || _elements.Count == 0)
            return null;

        var currentTime = DateTimeProvider.DateTimeOffSetUtcNow();

        // Find the reason with the soonest end time that's still in the future
        return _elements
            .Where(e => e.ReasonEndTime.HasValue && e.ReasonEndTime.Value > currentTime)
            .OrderBy(e => e.ReasonEndTime!.Value)
            .FirstOrDefault();
    }

    private string FormatTimeSpan(TimeSpan timeSpan) => timeSpan.ToString(@"mm\:ss");

    private string GetLocalizedReason(DtoNotChargingWithExpectedPowerReason reason)
    {
        if (reason.HasResourceKey && !string.IsNullOrWhiteSpace(reason.ResourceKey))
        {
            if (reason.FormatParameters.Count > 0)
            {
                return AppStringLocalizer[reason.ResourceKey, reason.FormatParameters.ToArray()];
            }

            return AppStringLocalizer[reason.ResourceKey];
        }

        return reason.Reason ?? string.Empty;
    }

    public void Dispose()
    {
        _countdownTimer?.Dispose();
    }
}